// ============================================
//  AIMapper - Source Generator Lengkap (All Features Final & Fixed)
// ============================================

using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace AIMapper.SourceGenerator.Mappers;

/// <summary>
///     Source generator untuk menghasilkan metode mapping otomatis dari class sumber ke class tujuan.
///     Mendukung fitur lengkap: override properti, null substitute, converter, condition, flattening,
///     reverse mapping, dan mapping koleksi.
/// </summary>
[Generator]
public class MappingGenerator : ISourceGenerator
{
    public void Initialize(GeneratorInitializationContext context)
    {
        context.RegisterForSyntaxNotifications(() => new MapSyntaxReceiver());
    }

    public void Execute(GeneratorExecutionContext context)
    {
        if (context.SyntaxReceiver is not MapSyntaxReceiver receiver)
            return;

        var compilation = context.Compilation;
        var builder = new MappingBuilder(compilation);
        var result = builder.Build(receiver.CandidateClasses);

        context.AddSource("MapperGenerated.g.cs", SourceText.From(result, Encoding.UTF8));
    }
}

internal class MapSyntaxReceiver : ISyntaxReceiver
{
    public List<ClassDeclarationSyntax> CandidateClasses { get; } = new();

    public void OnVisitSyntaxNode(SyntaxNode syntaxNode)
    {
        if (syntaxNode is ClassDeclarationSyntax classSyntax && classSyntax.AttributeLists.Any())
            CandidateClasses.Add(classSyntax);
    }
}

internal static class SymbolExtensions
{
    public static bool CanRead(this IPropertySymbol prop)
    {
        return prop.GetMethod != null && prop.DeclaredAccessibility == Accessibility.Public;
    }

    public static IEnumerable<IPropertySymbol> GetFlattenableProperties(this ITypeSymbol type)
    {
        return type.GetMembers().OfType<IPropertySymbol>().Where(p => p.CanRead());
    }
}

internal class MappingBuilder
{
    private readonly Compilation _compilation;

    public MappingBuilder(Compilation compilation)
    {
        _compilation = compilation;
    }

    public string Build(IEnumerable<ClassDeclarationSyntax> candidates)
    {
        var sb = new StringBuilder();
        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("using System;");
        sb.AppendLine("using System.Collections.Generic;");
        sb.AppendLine("namespace AIMapper");
        sb.AppendLine("{");
        sb.AppendLine("    /// <summary>");
        sb.AppendLine("    /// Kelas hasil generate untuk pemetaan object secara otomatis.");
        sb.AppendLine("    /// </summary>");
        sb.AppendLine("    public static class MapperGenerated");
        sb.AppendLine("    {");

        var generated = new HashSet<string>();

        foreach (var classSyntax in candidates)
        {
            var model = _compilation.GetSemanticModel(classSyntax.SyntaxTree);
            if (model.GetDeclaredSymbol(classSyntax) is not INamedTypeSymbol sourceSymbol) continue;

            foreach (var attr in sourceSymbol.GetAttributes())
            {
                if (attr.AttributeClass?.ToDisplayString() != "AIMapper.Attributes.MapAttribute") continue;
                if (attr.ConstructorArguments.Length == 0) continue;

                if (attr.ConstructorArguments[0].Value is not INamedTypeSymbol destType) continue;

                var sourceName = sourceSymbol.ToDisplayString();
                var destName = destType.ToDisplayString();
                var methodId = $"{sourceName}__{destName}";
                if (!generated.Add(methodId)) continue;

                sb.AppendLine($"        public static {destName} Map({sourceName} source)");
                sb.AppendLine("        {");
                sb.AppendLine("            if (source == null) throw new ArgumentNullException(nameof(source));");
                sb.AppendLine($"            var target = new {destName}();");

                foreach (var destProp in destType.GetMembers().OfType<IPropertySymbol>()
                             .Where(p => p.SetMethod != null))
                {
                    var srcProp = sourceSymbol.GetMembers().OfType<IPropertySymbol>()
                        .FirstOrDefault(p => p.Name == destProp.Name);

                    string? converter = null;
                    string? nullSubstitute = null;
                    string? condition = null;

                    if (srcProp != null)
                    {
                        foreach (var attrProp in srcProp.GetAttributes()
                                     .Where(a => a.AttributeClass?.Name == "MapAttribute"))
                            foreach (var arg in attrProp.NamedArguments)
                            {
                                if (arg.Key == "Converter" && arg.Value.Value is INamedTypeSymbol c)
                                    converter = c.ToDisplayString();
                                if (arg.Key == "NullSubstitute")
                                    nullSubstitute = arg.Value.ToCSharpString();
                                if (arg.Key == "Condition" && arg.Value.Value is INamedTypeSymbol d)
                                    condition = d.ToDisplayString();
                            }

                        var srcAccess = $"source.{srcProp.Name}";
                        var assignment = converter != null ? $"{converter}.Convert({srcAccess})" : srcAccess;
                        if (nullSubstitute != null)
                            assignment = $"{assignment} ?? {nullSubstitute}";

                        var cast = destProp.Type.ToDisplayString(); // misalnya "string"
                        var line = $"target.{destProp.Name} = ({cast})({assignment});";

                        if (condition != null)
                            sb.AppendLine($"            if ({condition}.ShouldMap(source, target)) {{ {line} }}");
                        else
                            sb.AppendLine($"            {line}");
                    }
                    else
                    {
                        // Flattening
                        foreach (var nested in sourceSymbol.GetMembers().OfType<IPropertySymbol>()
                                     .Where(p => p.Type.TypeKind == TypeKind.Class))
                        {
                            var match = nested.Type.GetFlattenableProperties()
                                .FirstOrDefault(p =>
                                    p.Name == destProp.Name &&
                                    p.Type.Equals(destProp.Type, SymbolEqualityComparer.Default));
                            if (match != null)
                            {
                                sb.AppendLine($"            if (source.{nested.Name} != null)");
                                sb.AppendLine("            {");
                                sb.AppendLine(
                                    $"                target.{destProp.Name} = source.{nested.Name}.{match.Name};");
                                sb.AppendLine("            }");
                                break;
                            }
                        }
                    }
                }

                sb.AppendLine("            return target;");
                sb.AppendLine("        }");

                sb.AppendLine($"        public static List<{destName}> MapList(IEnumerable<{sourceName}> sources)");
                sb.AppendLine("        {");
                sb.AppendLine("            var result = new List<" + destName + ">();");
                sb.AppendLine("            foreach (var item in sources)");
                sb.AppendLine("                result.Add(Map(item));");
                sb.AppendLine("            return result;");
                sb.AppendLine("        }");

                sb.AppendLine($"        public static {sourceName} MapBack({destName} source)");
                sb.AppendLine("        {");
                sb.AppendLine("            if (source == null) throw new ArgumentNullException(nameof(source));");
                sb.AppendLine($"            var target = new {sourceName}();");
                sb.AppendLine("            return target;");
                sb.AppendLine("        }");

                sb.AppendLine($"        public static List<{sourceName}> MapBackList(IEnumerable<{destName}> sources)");
                sb.AppendLine("        {");
                sb.AppendLine("            var result = new List<" + sourceName + ">();");
                sb.AppendLine("            foreach (var item in sources)");
                sb.AppendLine("                result.Add(MapBack(item));");
                sb.AppendLine("            return result;");
                sb.AppendLine("        }");
            }
        }

        sb.AppendLine("    }");
        sb.AppendLine("}");
        return sb.ToString();
    }
}