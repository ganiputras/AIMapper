using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace AIMapper.SourceGenerator.Mappers;

/// <summary>
/// Source generator untuk menghasilkan extension method mapping antar object berdasarkan attribute Map.
/// </summary>
[Generator]
public class MappingGenerator : ISourceGenerator
{
    public void Initialize(GeneratorInitializationContext context)
    {
        // Tidak perlu inisialisasi tambahan untuk generator sederhana
#if DEBUG
        // System.Diagnostics.Debugger.Launch(); // Uncomment untuk debug
#endif
    }

    public void Execute(GeneratorExecutionContext context)
    {
        // 1. Cari semua syntax yang ada attribute [Map]
        var syntaxTrees = context.Compilation.SyntaxTrees;
        var allClasses = syntaxTrees
            .SelectMany(st => st.GetRoot()
                .DescendantNodes()
                .OfType<ClassDeclarationSyntax>())
            .ToList();

        foreach (var classSyntax in allClasses)
        {
            var semanticModel = context.Compilation.GetSemanticModel(classSyntax.SyntaxTree);
            var symbol = semanticModel.GetDeclaredSymbol(classSyntax) as INamedTypeSymbol;
            if (symbol == null)
                continue;

            foreach (var attr in symbol.GetAttributes())
            {
                if (attr.AttributeClass?.Name is not ("MapAttribute" or "Map"))
                    continue;

                if (attr.ConstructorArguments.Length != 1)
                    continue;

                var targetType = attr.ConstructorArguments[0].Value as INamedTypeSymbol;
                if (targetType == null)
                    continue;

                var sourceTypeName = symbol.Name;
                var targetTypeName = targetType.Name;

                // Generate extension method code
                var sourceNamespace = symbol.ContainingNamespace.ToDisplayString();
                var targetNamespace = targetType.ContainingNamespace.ToDisplayString();

                var extClassName = $"{sourceTypeName}_To_{targetTypeName}_MapperExtensions";

                var mapMethod = GenerateMapMethod(symbol, targetType);

                var code = $@"// <auto-generated/>
    using System;

    namespace {sourceNamespace}.Generated
    {{
        /// <summary>
        /// Extension method hasil generate untuk mapping dari {sourceTypeName} ke {targetTypeName}
        /// </summary>
        public static partial class {extClassName}
        {{
            {mapMethod}
        }}
    }}
    ";
                // Add as source
                context.AddSource($"{extClassName}.g.cs", SourceText.From(code, Encoding.UTF8));
            }
        }
    }

    private string GenerateMapMethod(INamedTypeSymbol source, INamedTypeSymbol target)
    {
        var sourceTypeName = source.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
        var targetTypeName = target.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);

        // Ambil semua property yang cocok by name & type
        var targetProps = target.GetMembers().OfType<IPropertySymbol>().Where(p => p.SetMethod != null).ToList();
        var sourceProps = source.GetMembers().OfType<IPropertySymbol>().ToList();

        var assignments = new List<string>();

        foreach (var tProp in targetProps)
        {
            var sProp = sourceProps.FirstOrDefault(sp =>
                string.Equals(sp.Name, tProp.Name, StringComparison.OrdinalIgnoreCase)
                && SymbolEqualityComparer.Default.Equals(sp.Type, tProp.Type));
            if (sProp != null)
            {
                assignments.Add($"{tProp.Name} = source.{sProp.Name}");
            }
        }

        var assignCode = string.Join(",\n            ", assignments);

        return $@"
        /// <summary>
        /// Mapping otomatis ke tipe {target.Name}
        /// </summary>
        public static {targetTypeName} To{target.Name}(this {sourceTypeName} source)
        {{
            if (source == null) return null;
            return new {targetTypeName}
            {{
                {assignCode}
            }};
        }}";
    }
}
